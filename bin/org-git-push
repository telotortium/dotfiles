#!/usr/bin/env python

"""Sync Org git repos with upstream.

Assumes that each directory in `~/Documents/org` listed in the environment variable
`ORG_REPOS` is a Git repo containing org-mode files.

Set the environment variable `GIT` to use a custom `git` executable (uses the
one on the path by default).
"""

import optparse
import os
from pipes import quote as q
import re
import shutil
import subprocess as sp
import sys
import tempfile

parser = optparse.OptionParser()
parser.add_option('--noninteractive', action='store_true', dest='noninteractive')
parser.add_option('--verbose', action='store_true', dest='verbose')
(options, args) = parser.parse_args()

base_tag = 'org-git-push-base'

org_repos = os.environ.get('ORG_REPOS', '').split()
if not org_repos:
    sys.exit("No repos defined");
git = os.environ.get('GIT', 'git')

def log_and_run_cmd(cmd, verbose=False, check=True):
    if verbose:
        print >>sys.stderr, "{}: Running cmd: {}".format(sys.argv[0], cmd)
    if check:
        sp.check_call(cmd, shell=True)
    else:
        sp.call(cmd, shell=True)

exit = 0
for repo in org_repos:
    maintree = os.path.join(os.environ['HOME'], 'Documents', 'org', repo)
    print >>sys.stderr, "{}: Processing {}".format(sys.argv[0], maintree)
    try:
        current_branch = None
        os.chdir(maintree)
        current_branch = sp.check_output("git symbolic-ref --short HEAD", shell=True).strip()
        log_and_run_cmd(r"""GIT={} git fetch --all""".format(q(git)),
                        verbose=options.verbose)
        log_and_run_cmd(r"""GIT={} git tag --force {} {}""".format(
            q(git), q(base_tag), q(current_branch)),
                        verbose=options.verbose,
        )
        try:
            log_and_run_cmd(r"""GIT={} bash -c '$GIT pull {} --rebase --autostash 2> \
                            >( grep -vF "Successfully rebased and updated refs/heads/$0" 1>&2)' {}""".format(
                                q(git),
                                '--verbose' if options.verbose else '--quiet',
                                q(current_branch),
                            ),
                            verbose=options.verbose)
        except sp.CalledProcessError as e:
            if options.noninteractive:
                log_and_run_cmd("git rebase --abort",
                                verbose=options.verbose, check=False)
                log_and_run_cmd("git merge --abort",
                                verbose=options.verbose, check=False)
                exit = 1
                continue
            else:
                raise
        log_and_run_cmd(r"""GIT={git} bash -c '"$GIT" push {verbose} \
                        --force-with-lease="$0:$1" 2> \
                        >( grep -vF "Resolving deltas" 1>&2 )' {base} {current}""".format(
                            git=q(git),
                            verbose=('--verbose' if options.verbose else '--quiet'),
                            base=q(base_tag), current=q(current_branch),
                        ),
                        verbose=options.verbose)
        # Update current status of remote tracking branches after push
        log_and_run_cmd(r"""GIT={} git fetch --all""".format(q(git)),
                        verbose=options.verbose)
    except sp.CalledProcessError as e:
        print >>sys.stderr, e
        exit = 1
        continue
    finally:
        if current_branch is not None:
            log_and_run_cmd(r"""GIT={} git checkout {}""".format(
                q(git), q(current_branch)), verbose=options.verbose, check=False)
sys.exit(exit)
